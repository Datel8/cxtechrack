<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CX.TECH Rack Manager Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* CX.TECH Brand Colors */
            --cx-orange: #f89a55;
            --cx-black: #000000;
            --cx-white: #ffffff;
            
            /* Application colors based on CX.TECH brand */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --accent-primary: #f89a55;
            --accent-secondary: #ff7a35;
            --accent-tertiary: #ffaa75;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #3a3a3a;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #f87171;
            --info: #60a5fa;
            
            /* Legacy color mappings for compatibility */
            --accent-cyan: var(--accent-primary);
            --accent-magenta: var(--accent-secondary);
            --accent-yellow: var(--accent-tertiary);
            --rack-bg: #0f0f0f;
            --rack-border: rgba(248, 154, 85, 0.3);
            --sidebar-bg: #0c0c0c;
            --panel-surface: #151515;
            --panel-surface-2: #1f1f1f;
            --shadow-soft: 0 20px 60px rgba(0, 0, 0, 0.45);
        }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body.auth-locked .app-shell {
            pointer-events: none;
            user-select: none;
            filter: blur(2px);
            opacity: 0.6;
        }
        
        /* Animated background with CX.TECH orange accents */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, var(--cx-orange) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, var(--cx-orange) 0%, transparent 40%),
                radial-gradient(circle at 40% 20%, var(--cx-orange) 0%, transparent 45%);
            opacity: 0.02;
            z-index: -1;
            animation: backgroundPulse 20s ease-in-out infinite;
        }
        
        @keyframes backgroundPulse {
            0%, 100% { opacity: 0.03; }
            50% { opacity: 0.06; }
        }
        
        /* MSP layout */
        .app-shell {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: 100vh;
        }

        .sidebar {
            background: linear-gradient(180deg, var(--sidebar-bg), #121212 80%);
            border-right: none;
            padding: 2rem 1.5rem;
            min-height: 100vh;
            position: relative;
            overflow: visible;
        }

        .sidebar-brand {
            margin-bottom: 2rem;
        }

        .brand-title {
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .brand-title .cx,
        .brand-title .tech {
            color: var(--cx-white);
        }

        .brand-title .dot {
            color: var(--cx-orange);
        }

        .brand-subtitle {
            margin-top: 0.35rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .sidebar-section {
            margin-bottom: 1.75rem;
        }

        .section-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .sidebar-nav {
            display: grid;
            gap: 0.5rem;
        }

        .nav-btn {
            text-align: left;
            width: 100%;
            padding: 0.75rem 0.9rem;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--panel-surface);
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .nav-btn.active {
            border-color: var(--cx-orange);
            box-shadow: 0 0 0 1px rgba(248, 154, 85, 0.4);
            background: linear-gradient(135deg, rgba(248, 154, 85, 0.25), rgba(20, 20, 20, 0.8));
        }

        .nav-btn:hover:not(.active) {
            transform: translateX(6px);
            border-color: rgba(248, 154, 85, 0.5);
        }

        .main-content {
            padding: 2rem;
        }

        .topbar {
            background: linear-gradient(120deg, #1b1b1b, #101010);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1.5rem;
            flex-wrap: wrap;
            box-shadow: var(--shadow-soft);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .topbar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 40%;
            height: 100%;
            background: radial-gradient(circle at right, rgba(248, 154, 85, 0.2), transparent 70%);
            opacity: 0.8;
        }

        .topbar-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .topbar-subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 0.35rem;
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            z-index: 1;
        }

        .auth-status {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: 'IBM Plex Mono', monospace;
        }

        .auth-overlay {
            position: fixed;
            inset: 0;
            background: rgba(8, 8, 8, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
        }

        .auth-overlay.hidden {
            display: none;
        }

        .auth-card {
            background: var(--panel-surface-2);
            border: 1px solid var(--border-color);
            border-radius: 18px;
            padding: 2rem;
            width: min(420px, 90vw);
            box-shadow: var(--shadow-soft);
            text-align: left;
        }

        .auth-card h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .auth-card p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .auth-stack {
            display: grid;
            gap: 0.75rem;
        }

        .auth-hint {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .role-manager-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .role-manager-table th,
        .role-manager-table td {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .role-manager-table th {
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .role-select {
            width: 100%;
            padding: 0.4rem 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
        }

        .role-note {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 0.5rem;
        }

        .role-invite-form {
            display: grid;
            grid-template-columns: 1fr 160px 140px;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .role-invite-form input {
            width: 100%;
            padding: 0.5rem 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
        }

        .role-invite-list {
            margin-top: 1rem;
        }

        @media (max-width: 1100px) {
            .app-shell {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: relative;
                height: auto;
            }

            .main-content {
                padding: 1.5rem;
            }
        }

        @media (max-width: 700px) {
            .sidebar {
                padding: 1.5rem 1rem;
            }

            .topbar {
                padding: 1rem 1.25rem;
            }
        }
        
        .control-section {
            margin-bottom: 2rem;
        }
        
        .control-section h3 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            font-weight: 500;
        }
        
        .btn {
            width: 100%;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, var(--cx-orange), #ff6a25);
            color: var(--cx-white);
            border: none;
            border-radius: 8px;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(248, 154, 85, 0.3);
            background: linear-gradient(135deg, #ff6a25, var(--cx-orange));
        }
        
        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled,
        .btn-small:disabled,
        .delete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .btn-secondary {
            background: transparent;
            border: 2px solid var(--cx-orange);
            color: var(--cx-orange);
        }
        
        .btn-secondary:hover {
            background: rgba(248, 154, 85, 0.1);
            border-color: var(--cx-orange);
            box-shadow: 0 0 20px rgba(248, 154, 85, 0.2);
        }
        
        /* Form elements */
        .form-group {
            margin-bottom: 1rem;
        }
        
        .form-group label {
            display: block;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
            transition: all 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        
        /* Rack visualization */
        .rack-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--border-color);
        }
        
        .rack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        
        .rack-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .rack-stats {
            display: flex;
            gap: 2rem;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--accent-cyan);
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .rack-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }
        
        .rack {
            background: var(--rack-bg);
            border: 2px solid var(--rack-border);
            border-radius: 8px;
            padding: 1rem;
            position: relative;
            transition: all 0.3s;
        }
        
        .rack:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            transform: translateY(-4px);
        }
        
        .rack-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--accent-cyan);
        }
        
        .rack-units {
            display: flex;
            flex-direction: column-reverse;
            gap: 2px;
            background: #000;
            padding: 4px;
            border-radius: 4px;
        }
        
        .rack-unit {
            height: 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            position: relative;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625rem;
            color: var(--text-secondary);
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .rack-unit.occupied {
            cursor: pointer;
            background: var(--device-gradient, var(--bg-tertiary));
            border-color: var(--device-color, var(--border-color));
            color: var(--device-text, var(--text-primary));
        }
        
        .rack-unit.occupied.switch {
            background: linear-gradient(90deg, #00ffff, #0099ff);
            border-color: #00ffff;
            color: #000;
        }
        
        .rack-unit.occupied.router {
            background: linear-gradient(90deg, #ff00ff, #9900ff);
            border-color: #ff00ff;
            color: #fff;
        }
        
        .rack-unit.occupied.server {
            background: linear-gradient(90deg, #ffff00, #ff9900);
            border-color: #ffff00;
            color: #000;
        }
        
        .rack-unit.occupied.patch {
            background: linear-gradient(90deg, #00ff88, #00cc66);
            border-color: #00ff88;
            color: #000;
        }
        
        .rack-unit.occupied:hover {
            transform: scaleX(1.05);
            z-index: 10;
            box-shadow: 0 0 20px currentColor;
        }
        
        /* Device info tooltip */
        .device-tooltip {
            position: absolute;
            background: var(--bg-primary);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 1rem;
            z-index: 1000;
            min-width: 250px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            display: none;
            animation: tooltipFadeIn 0.3s;
        }
        
        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .device-tooltip.active {
            display: block;
        }
        
        .tooltip-header {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--accent-cyan);
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .tooltip-detail {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        
        /* Device list */
        .device-list {
            margin-top: 2rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--border-color);
        }
        
        .device-list h3 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
        }
        
        .device-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .device-table th {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 2px solid var(--border-color);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }
        
        .device-table td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
        }
        
        .device-table tr:hover {
            background: var(--bg-tertiary);
        }
        
        .device-type-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            background: var(--badge-bg, rgba(248, 154, 85, 0.15));
            color: var(--badge-color, var(--text-primary));
            border: 1px solid var(--badge-border, transparent);
        }
        
        .device-type-badge.switch {
            background: rgba(0, 255, 255, 0.2);
            color: var(--accent-cyan);
        }
        
        .device-type-badge.router {
            background: rgba(255, 0, 255, 0.2);
            color: var(--accent-magenta);
        }
        
        .device-type-badge.server {
            background: rgba(255, 255, 0, 0.2);
            color: var(--accent-yellow);
        }
        
        .device-type-badge.patch {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
        }
        
        .delete-btn {
            background: transparent;
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.3s;
        }
        
        .delete-btn:hover {
            background: var(--danger);
            color: var(--text-primary);
        }

        /* Module management */
        .module-list {
            display: grid;
            gap: 0.75rem;
        }

        .module-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .module-meta {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
        }

        .module-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .module-id {
            color: var(--text-secondary);
        }

        /* MSP modules */
        .msp-modules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .msp-module-card {
            background: var(--panel-surface-2);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 160px;
            box-shadow: 0 20px 35px rgba(0, 0, 0, 0.25);
            transition: transform 0.25s ease, border-color 0.25s ease;
        }

        .msp-module-card:hover {
            transform: translateY(-4px);
            border-color: rgba(248, 154, 85, 0.6);
        }

        .msp-module-title {
            font-size: 1.05rem;
            font-weight: 600;
        }

        .msp-module-meta {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }

        .msp-module-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .msp-module-status {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--cx-orange);
        }

        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .overview-card {
            background: linear-gradient(135deg, rgba(248, 154, 85, 0.15), rgba(20, 20, 20, 0.9));
            border: 1px solid rgba(248, 154, 85, 0.4);
            border-radius: 14px;
            padding: 1.25rem;
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
        }

        .overview-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
        }

        .overview-card-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-secondary);
        }

        .overview-card-value {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 0.35rem;
        }

        .overview-card-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .overview-section {
            margin-top: 2rem;
        }

        .overview-section-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .topology-group {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 8px;
            border: 2px solid var(--border-color);
        }

        .topology-group-grid {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: modalFadeIn 0.3s;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .modal-header h2 {
            font-size: 1.5rem;
            color: var(--accent-cyan);
        }
        
        .modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        .modal-close:hover {
            color: var(--accent-cyan);
        }
        
        /* Connections view */
        .connections-container {
            margin-top: 2rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--border-color);
        }
        
        .connection-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 1rem;
            transition: all 0.3s;
        }
        
        .connection-item:hover {
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        
        .connection-from, .connection-to {
            flex: 1;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .connection-arrow {
            margin: 0 1rem;
            color: var(--accent-cyan);
            font-size: 1.5rem;
        }
        
        
        /* Client selector */
        .client-selector-container {
            display: grid;
            gap: 0.75rem;
            align-items: center;
            margin: 0 0 1rem;
            padding: 0;
            background: transparent;
            border-radius: 0;
            border: none;
        }
        
        .client-selector {
            width: 100%;
            max-width: none;
            padding: 0.75rem;
            background: var(--panel-surface-2);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .client-selector:focus {
            outline: none;
            box-shadow: 0 0 20px rgba(248, 154, 85, 0.35);
            border-color: rgba(248, 154, 85, 0.6);
        }
        
        .btn-small {
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, var(--cx-orange), #ff6a25);
            color: #101010;
            border: none;
            border-radius: 6px;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .btn-small:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(248, 154, 85, 0.3);
        }
        
        /* Client info panel */
        .client-info {
            background: linear-gradient(135deg, rgba(248, 154, 85, 0.15), rgba(40, 40, 40, 0.4));
            border: 1px solid rgba(248, 154, 85, 0.4);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
        }
        
        .client-info h4 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--cx-orange);
            margin-bottom: 0.5rem;
        }
        
        .client-info-detail {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .client-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: linear-gradient(135deg, var(--cx-orange), #ff6a25);
            color: #0b0b0b;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-right: 0.5rem;
        }
        
        .no-client-warning {
            background: rgba(255, 170, 0, 0.1);
            border: 2px dashed var(--warning);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            color: var(--warning);
            margin: 2rem 0;
        }
        
        .client-list {
            display: grid;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .client-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
        }
        
        .client-card:hover {
            border-color: var(--accent-cyan);
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        
        .client-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .client-card-name {
            font-weight: 600;
            color: var(--accent-cyan);
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .client-card-stats {
            display: flex;
            gap: 1.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
        
        .client-actions {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
        }
        
        .btn-icon {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-icon:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }
        
        .btn-icon.danger:hover {
            border-color: var(--danger);
            color: var(--danger);
        }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        /* Network Visualization */
        .view-toggle {
            display: none;
        }
        
        .view-toggle-btn {
            text-align: left;
            width: 100%;
            padding: 0.75rem 0.9rem;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--panel-surface);
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        
        .view-toggle-btn.active {
            border-color: var(--cx-orange);
            box-shadow: 0 0 0 1px rgba(248, 154, 85, 0.4);
            background: linear-gradient(135deg, rgba(248, 154, 85, 0.25), rgba(20, 20, 20, 0.8));
        }
        
        .view-toggle-btn:hover:not(.active) {
            transform: translateX(6px);
            border-color: rgba(248, 154, 85, 0.5);
        }
        
        /* Network Map Container */
        .network-map {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
            min-height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        #networkCanvas {
            width: 100%;
            height: 500px;
            cursor: grab;
        }
        
        #networkCanvas:active {
            cursor: grabbing;
        }
        
        /* Port Management */
        .port-details-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .port-details-overlay.active {
            display: flex;
            animation: fadeIn 0.3s;
        }
        
        .port-details-container {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 2rem;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideIn 0.3s;
        }
        
        .port-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .port-details-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-cyan);
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .port-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
            margin-bottom: 2rem;
        }
        
        .port-item {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .port-item:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .port-item.connected {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
        }
        
        .port-item.connected::after {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .port-item.trunk {
            border-color: var(--accent-magenta);
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1), rgba(255, 0, 255, 0.05));
        }
        
        .port-item.uplink {
            border-color: var(--accent-cyan);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 255, 0.05));
        }
        
        .port-item.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .port-number {
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-primary);
        }
        
        .port-label {
            font-size: 0.625rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Connection Lines */
        .connection-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
            transform-origin: left center;
            pointer-events: none;
            z-index: 1;
            opacity: 0.6;
            animation: flowAnimation 3s linear infinite;
        }
        
        @keyframes flowAnimation {
            0% {
                background-position: 0% 50%;
            }
            100% {
                background-position: 100% 50%;
            }
        }
        
        .connection-line.active {
            opacity: 1;
            box-shadow: 0 0 10px var(--accent-cyan);
        }
        
        /* Port configuration modal */
        .port-config-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .port-config-form .form-group {
            margin-bottom: 0;
        }
        
        .port-config-form .form-group.full-width {
            grid-column: 1 / -1;
        }
        
        /* VLAN tags */
        .vlan-tag {
            display: inline-block;
            padding: 0.125rem 0.375rem;
            background: rgba(255, 255, 0, 0.2);
            color: var(--accent-yellow);
            border-radius: 4px;
            font-size: 0.625rem;
            font-weight: 600;
            margin-right: 0.25rem;
        }
        
        /* Connection path visualization */
        .connection-path {
            display: flex;
            align-items: center;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 1rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
        }
        
        .connection-path-device {
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            color: var(--bg-primary);
            border-radius: 6px;
            font-weight: 600;
        }
        
        .connection-path-arrow {
            margin: 0 1rem;
            color: var(--accent-cyan);
        }
        
        .connection-path-port {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }
        
        /* Network stats */
        .network-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .network-stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        
        .network-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .network-stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0.25rem;
        }
    </style>
</head>


<body class="auth-locked">
    <div id="authOverlay" class="auth-overlay">
        <div class="auth-card">
            <h2>Prihlaseni</h2>
            <p>Pro pristup do MSP konzole se prihlaste pres Google ucet.</p>
            <div class="auth-stack">
                <button class="btn" onclick="loginWithGoogle()">Prihlasit pres Google</button>
                <input type="email" id="emailLoginInput" placeholder="email@firma.cz">
                <button class="btn btn-secondary" onclick="sendMagicLink()">Poslat magic link</button>
                <div class="auth-hint">Magic link prijde na e-mail.</div>
                <button class="btn btn-secondary" id="localAdminBtn" onclick="enableLocalAdmin()" style="display: none;">Lokalni admin</button>
            </div>
        </div>
    </div>
    <div class="app-shell">
        <aside class="sidebar">
            <div class="sidebar-brand">
                <div class="brand-title"><span class="cx">CX</span><span class="dot">.</span><span class="tech">TECH</span></div>
                <div class="brand-subtitle">Rack Manager - MSP Console</div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Klient</div>
                <div class="client-selector-container">
                    <select id="clientSelector" class="client-selector" onchange="switchClient()">
                        <option value="">-- Vyberte klienta --</option>
                    </select>
                    <button class="btn-small" onclick="openClientModal()">+ Novy klient</button>
                </div>
                <div class="client-info" id="clientInfo" style="display: none;">
                    <h4>Aktivni klient</h4>
                    <div class="client-info-detail" id="clientName"></div>
                    <div class="client-info-detail" id="userRole"></div>
                    <div class="client-info-detail" id="clientContact"></div>
                    <div class="client-info-detail" id="clientLocation"></div>
                    <div style="margin-top: 0.5rem;">
                        <span class="client-badge" id="clientType"></span>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="openClientManagerModal()">Spravovat klienty</button>
                <button class="btn btn-secondary" id="roleManagerBtn" onclick="openRoleManagerModal()">Sprava roli</button>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Navigace</div>
                <div class="sidebar-nav">
                    <button class="view-toggle-btn nav-btn active" data-view="racks" onclick="switchView('racks', this)">Racky</button>
                    <button class="view-toggle-btn nav-btn" data-view="network" onclick="switchView('network', this)">Sitova mapa</button>
                    <button class="view-toggle-btn nav-btn" data-view="topology" onclick="switchView('topology', this)">Topologie</button>
                    <button class="view-toggle-btn nav-btn" data-view="overview" onclick="switchView('overview', this)">Prehled klienta</button>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Racky</div>
                <button class="btn" onclick="openRackModal()" id="addRackBtn" disabled>Pridat rack</button>
                <button class="btn btn-secondary" onclick="clearAllRacks()" id="clearRacksBtn" disabled>Vymazat vse</button>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Zarizeni</div>
                <button class="btn" onclick="openDeviceModal()" id="addDeviceBtn" disabled>Pridat zarizeni</button>
                <button class="btn" onclick="openConnectionModal()" id="addConnectionBtn" disabled>Pridat propojeni</button>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Kategorie zarizeni</div>
                <button class="btn btn-secondary" onclick="openModuleModal()">Sprava kategorii</button>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Statistiky</div>
                <div class="stat">
                    <div class="stat-value" id="totalDevices">0</div>
                    <div class="stat-label">Celkem zarizeni</div>
                </div>
                <div class="stat" style="margin-top: 1rem;">
                    <div class="stat-value" id="totalRacks">0</div>
                    <div class="stat-label">Celkem racku</div>
                </div>
            </div>
        </aside>

        <main class="main-content">
            <div class="topbar">
                <div>
                    <div class="topbar-title">MSP Operations Desk</div>
                    <div class="topbar-subtitle">Multi-tenant sprava infrastruktury</div>
                </div>
                <div class="topbar-actions">
                    <div id="authStatus" class="auth-status">Neprihlasen</div>
                    <button class="btn-small" id="loginBtn" onclick="loginWithGoogle()">Prihlasit</button>
                    <button class="btn btn-secondary" id="logoutBtn" onclick="logout()" style="display: none;">Odhlasit</button>
                </div>
            </div>

            <div id="overviewView" class="rack-container" style="display: none;">
                <div class="rack-header">
                    <h2>Prehled klienta</h2>
                    <div class="rack-stats">
                        <div class="stat">
                            <div class="stat-value" id="overviewClientName">-</div>
                            <div class="stat-label">Aktivni klient</div>
                        </div>
                    </div>
                </div>
                <p class="msp-module-desc">Kliknete na karty pro rychly prechod do detailu racku, zarizeni nebo site.</p>
                <div id="overviewGrid" class="overview-grid"></div>

                <div class="overview-section">
                    <div class="overview-section-title">MSP sluzby</div>
                    <div id="mspModulesGrid" class="msp-modules-grid"></div>
                </div>
            </div>
            
            <div id="racksView" class="rack-container">
                <div class="rack-header">
                    <h2>Racky</h2>
                    <div class="rack-stats">
                        <div class="stat">
                            <div class="stat-value" id="usedUnits">0</div>
                            <div class="stat-label">Obsazeno U</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="freeUnits">0</div>
                            <div class="stat-label">Volno U</div>
                        </div>
                    </div>
                </div>
                <div id="rackGrid" class="rack-grid">
                    <div class="empty-state">
                        <div class="empty-state-icon">游닍</div>
                        <p>Zat칤m nem치te 쮂멳n칠 racky.<br>Klikn캩te na "P콏idat rack" pro vytvo콏en칤 prvn칤ho racku.</p>
                    </div>
                </div>
            </div>
            
            <div id="networkView" class="network-map" style="display: none;">
                <div class="rack-header">
                    <h2>S칤콘ov치 mapa</h2>
                    <div class="rack-stats">
                        <button class="btn-small" onclick="resetNetworkView()">游댃 Reset View</button>
                        <button class="btn-small" onclick="exportNetworkDiagram()">游닌 Export SVG</button>
                    </div>
                </div>
                <div class="network-stats">
                    <div class="network-stat-card">
                        <div class="network-stat-value" id="totalConnections">0</div>
                        <div class="network-stat-label">Propojen칤</div>
                    </div>
                    <div class="network-stat-card">
                        <div class="network-stat-value" id="totalPorts">0</div>
                        <div class="network-stat-label">Port콢 celkem</div>
                    </div>
                    <div class="network-stat-card">
                        <div class="network-stat-value" id="usedPorts">0</div>
                        <div class="network-stat-label">Obsazeno</div>
                    </div>
                    <div class="network-stat-card">
                        <div class="network-stat-value" id="trunkPorts">0</div>
                        <div class="network-stat-label">Trunk port콢</div>
                    </div>
                </div>
                <canvas id="networkCanvas"></canvas>
            </div>
            
            <div id="topologyView" style="display: none;">
                <!-- Topology view will be dynamically generated -->
            </div>
            
            <div class="device-list" id="deviceListContainer" style="display: none;">
                <h3>Seznam za콏칤zen칤</h3>
                <table class="device-table">
                    <thead>
                        <tr>
                            <th>N치zev</th>
                            <th>Typ</th>
                            <th>Rack</th>
                            <th>Pozice</th>
                            <th>IP adresa</th>
                            <th>Model</th>
                            <th>Akce</th>
                        </tr>
                    </thead>
                    <tbody id="deviceTableBody">
                    </tbody>
                </table>
            </div>
            
            <div class="connections-container" id="connectionsContainer" style="display: none;">
                <h3>Propojen칤</h3>
                <div id="connectionsList">
                </div>
            </div>
        </main>
    </div>

    <!-- Port Details Overlay -->
    <div id="portDetailsOverlay" class="port-details-overlay">
        <div class="port-details-container">
            <div class="port-details-header">
                <h2 class="port-details-title" id="portDetailsTitle">Port Management</h2>
                <button class="modal-close" onclick="closePortDetails()">칑</button>
            </div>
            <div id="portDetailsContent">
                <!-- Port details will be rendered here -->
            </div>
        </div>
    </div>
    
    <!-- Connection Modal -->
    <div id="connectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Nov칠 propojen칤</h2>
                <button class="modal-close" onclick="closeConnectionModal()">칑</button>
            </div>
            <div class="form-group">
                <label>Z za콏칤zen칤</label>
                <select id="connFromDevice" onchange="updateFromPorts()"></select>
            </div>
            <div class="form-group">
                <label>Z portu</label>
                <select id="connFromPort"></select>
            </div>
            <div class="form-group">
                <label>Do za콏칤zen칤</label>
                <select id="connToDevice" onchange="updateToPorts()"></select>
            </div>
            <div class="form-group">
                <label>Do portu</label>
                <select id="connToPort"></select>
            </div>
            <div class="form-group">
                <label>Typ spojen칤</label>
                <select id="connType">
                    <option value="access">Access</option>
                    <option value="trunk">Trunk</option>
                    <option value="uplink">Uplink</option>
                    <option value="crossover">Crossover</option>
                </select>
            </div>
            <div class="form-group">
                <label>VLAN (캜치rkou odd캩len칠 pro trunk)</label>
                <input type="text" id="connVlans" placeholder="nap콏. 10,20,30">
            </div>
            <div class="form-group">
                <label>Rychlost</label>
                <select id="connSpeed">
                    <option value="10">10 Mbps</option>
                    <option value="100">100 Mbps</option>
                    <option value="1000" selected>1 Gbps</option>
                    <option value="10000">10 Gbps</option>
                    <option value="25000">25 Gbps</option>
                    <option value="40000">40 Gbps</option>
                    <option value="100000">100 Gbps</option>
                </select>
            </div>
            <div class="form-group">
                <label>Popis</label>
                <input type="text" id="connDescription" placeholder="nap콏. Uplink to core switch">
            </div>
            <button class="btn" onclick="addConnection()">Vytvo콏it propojen칤</button>
        </div>
    </div>
    
    <!-- Client Modal -->
    <div id="clientModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Nov칳 klient</h2>
                <button class="modal-close" onclick="closeClientModal()">칑</button>
            </div>
            <div class="form-group">
                <label>N치zev klienta *</label>
                <input type="text" id="newClientName" placeholder="nap콏. Firma ABC s.r.o.">
            </div>
            <div class="form-group">
                <label>I캛O</label>
                <input type="text" id="newClientICO" placeholder="nap콏. 12345678">
            </div>
            <div class="form-group">
                <label>Typ klienta</label>
                <select id="newClientType">
                    <option value="standard">Standard</option>
                    <option value="premium">Premium</option>
                    <option value="enterprise">Enterprise</option>
                </select>
            </div>
            <div class="form-group">
                <label>Kontaktn칤 osoba</label>
                <input type="text" id="newClientContact" placeholder="nap콏. Jan Nov치k">
            </div>
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="newClientEmail" placeholder="nap콏. info@firma.cz">
            </div>
            <div class="form-group">
                <label>Telefon</label>
                <input type="tel" id="newClientPhone" placeholder="nap콏. +420 123 456 789">
            </div>
            <div class="form-group">
                <label>Adresa</label>
                <input type="text" id="newClientAddress" placeholder="nap콏. V치clavsk칠 n치m캩st칤 1, Praha">
            </div>
            <div class="form-group">
                <label>Pozn치mky</label>
                <textarea id="newClientNotes" rows="3" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-family: 'IBM Plex Mono', monospace; font-size: 0.875rem;"></textarea>
            </div>
            <button class="btn" onclick="addClient()">Vytvo콏it klienta</button>
        </div>
    </div>
    
    <!-- Client Manager Modal -->
    <div id="clientManagerModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>Spr치va klient콢</h2>
                <button class="modal-close" onclick="closeClientManagerModal()">칑</button>
            </div>
            <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                <input type="text" id="clientSearch" placeholder="Hledat klienta..." style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary);" onkeyup="searchClients()">
                <button class="btn-small" onclick="openClientModal()">+ Nov칳 klient</button>
            </div>
            <div id="clientList" class="client-list">
                <!-- Clients will be rendered here -->
            </div>
        </div>
    </div>
    
    <!-- Role Manager Modal -->
    <div id="roleManagerModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>Sprava roli</h2>
                <button class="modal-close" onclick="closeRoleManagerModal()">X</button>
            </div>
            <div class="role-note">Role jsou nacitane z Firebase cesty clients/{id}/users.</div>
            <div class="role-invite-form">
                <input type="email" id="roleInviteEmail" placeholder="email@firma.cz">
                <select id="roleInviteRole" class="role-select">
                    <option value="admin">Admin</option>
                    <option value="technician">Technik</option>
                    <option value="readonly">Read-only</option>
                    <option value="auditor">Auditor</option>
                </select>
                <button class="btn btn-secondary" onclick="addRoleInvite()">Pozvat</button>
            </div>
            <div id="roleManagerList"></div>
        </div>
    </div>

    <!-- Rack Modal -->
    <div id="rackModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Nov칳 rack</h2>
                <button class="modal-close" onclick="closeRackModal()">칑</button>
            </div>
            <div class="form-group">
                <label>N치zev racku</label>
                <input type="text" id="rackName" placeholder="nap콏. RACK-01">
            </div>
            <div class="form-group">
                <label>Po캜et U (v칳코ka)</label>
                <input type="number" id="rackUnits" value="42" min="1" max="50">
            </div>
            <div class="form-group">
                <label>Um칤st캩n칤</label>
                <input type="text" id="rackLocation" placeholder="nap콏. Serverovna A">
            </div>
            <button class="btn" onclick="addRack()">Vytvo콏it rack</button>
        </div>
    </div>
    
    <!-- Device Modal -->
    <div id="deviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Nov칠 za콏칤zen칤</h2>
                <button class="modal-close" onclick="closeDeviceModal()">칑</button>
            </div>
            <div class="form-group">
                <label>N치zev za콏칤zen칤</label>
                <input type="text" id="deviceName" placeholder="nap콏. SW-CORE-01">
            </div>
            <div class="form-group">
                <label>Typ za콏칤zen칤</label>
                <select id="deviceType"></select>
                <div style="margin-top: 0.5rem; text-align: right;">
                    <button class="btn-small" onclick="openModuleModal()">Sprava kategorii</button>
                </div>
            </div>
            <div class="form-group">
                <label>Rack</label>
                <select id="deviceRack"></select>
            </div>
            <div class="form-group">
                <label>Pozice U (od spodu)</label>
                <input type="number" id="devicePosition" min="1" placeholder="nap콏. 10">
            </div>
            <div class="form-group">
                <label>V칳코ka (po캜et U)</label>
                <input type="number" id="deviceHeight" value="1" min="1" max="10">
            </div>
            <div class="form-group">
                <label>IP adresa</label>
                <input type="text" id="deviceIP" placeholder="nap콏. 192.168.1.1">
            </div>
            <div class="form-group">
                <label>Model</label>
                <input type="text" id="deviceModel" placeholder="nap콏. Cisco Catalyst 2960">
            </div>
            <div class="form-group">
                <label>S칠riov칠 캜칤slo</label>
                <input type="text" id="deviceSerial" placeholder="nap콏. ABC123456">
            </div>
            <div class="form-group">
                <label>Po캜et port콢</label>
                <input type="number" id="devicePorts" value="24" min="1" max="48" placeholder="nap콏. 24">
            </div>
    <button class="btn" onclick="addDevice()">P콏idat za콏칤zen칤</button>
        </div>
    </div>

    <!-- Module Modal -->
    <div id="moduleModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Kategorie zarizeni</h2>
                <button class="modal-close" onclick="closeModuleModal()">X</button>
            </div>
            <div class="form-group">
                <label>Nazev kategorie</label>
                <input type="text" id="moduleName" placeholder="napr. Firewall">
            </div>
            <div class="form-group">
                <label>ID kategorie (volitelne)</label>
                <input type="text" id="moduleId" placeholder="napr. firewall">
            </div>
            <div class="form-group">
                <label>Kategorie</label>
                <select id="moduleGroup">
                    <option value="Network">Network</option>
                    <option value="Compute">Compute</option>
                    <option value="Storage">Storage</option>
                    <option value="Security">Security</option>
                    <option value="Cabling">Cabling</option>
                    <option value="Other">Other</option>
                </select>
            </div>
            <div class="form-group">
                <label>Barva</label>
                <input type="color" id="moduleColor" value="#00ff88">
            </div>
            <button class="btn" onclick="addModuleType()">Pridat kategorii</button>

            <div style="margin-top: 1.5rem;">
                <h3 style="margin-bottom: 0.75rem; font-size: 0.875rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-secondary);">Seznam kategorii</h3>
                <div id="moduleList" class="module-list"></div>
            </div>
        </div>
    </div>

    <!-- Device Tooltip -->
    <div id="deviceTooltip" class="device-tooltip">
        <div class="tooltip-header" id="tooltipName"></div>
        <div class="tooltip-detail" id="tooltipType"></div>
        <div class="tooltip-detail" id="tooltipPosition"></div>
        <div class="tooltip-detail" id="tooltipIP"></div>
        <div class="tooltip-detail" id="tooltipModel"></div>
        <div class="tooltip-detail" id="tooltipSerial"></div>
    </div>
    
    <script>
        // Data storage - now with multi-tenant support
        let clients = [];
        let currentClientId = null;
        let clientData = {}; // Will store data per client
        
        // Current client's data
        let racks = [];
        let devices = [];
        let connections = [];

        // Module types
        const DEFAULT_MODULE_TYPES = [
            { id: 'switch', label: 'Switch', color: '#00ffff', gradient: ['#00ffff', '#0099ff'], text: '#000000', group: 'Network' },
            { id: 'router', label: 'Router', color: '#ff00ff', gradient: ['#ff00ff', '#9900ff'], text: '#ffffff', group: 'Network' },
            { id: 'server', label: 'Server', color: '#ffff00', gradient: ['#ffff00', '#ff9900'], text: '#000000', group: 'Compute' },
            { id: 'patch', label: 'Patch panel', color: '#00ff88', gradient: ['#00ff88', '#00cc66'], text: '#000000', group: 'Cabling' }
        ];
        let moduleTypes = [];
        let customModuleTypes = [];

        const ROLE_PERMISSIONS = {
            admin: {
                deleteRacks: true,
                editTopology: true,
                viewSensitive: true,
                manageRacks: true,
                manageDevices: true,
                manageCategories: true,
                manageRoles: true
            },
            technician: {
                deleteRacks: false,
                editTopology: true,
                viewSensitive: true,
                manageRacks: true,
                manageDevices: true,
                manageCategories: false,
                manageRoles: false
            },
            readonly: {
                deleteRacks: false,
                editTopology: false,
                viewSensitive: false,
                manageRacks: false,
                manageDevices: false,
                manageCategories: false,
                manageRoles: false
            },
            auditor: {
                deleteRacks: false,
                editTopology: false,
                viewSensitive: true,
                manageRacks: false,
                manageDevices: false,
                manageCategories: false,
                manageRoles: false
            }
        };

        const ROLE_LABELS = {
            admin: 'Admin',
            technician: 'Technik',
            readonly: 'Read-only',
            auditor: 'Auditor'
        };

        let currentUserRole = 'readonly';

        const mspModules = [
            {
                id: 'config-backup',
                name: 'Zaloha konfiguraci',
                category: 'Backup',
                status: 'planned',
                description: 'Automaticke ukladani konfiguraci sitovych zarizeni.'
            },
            {
                id: 'compliance-audit',
                name: 'Kontrola konfiguraci',
                category: 'Security',
                status: 'planned',
                description: 'Kontrola odchylek od standardu a schvalenych sablon.'
            },
            {
                id: 'patch-management',
                name: 'Patch management',
                category: 'Maintenance',
                status: 'planned',
                description: 'Planovani a evidovani aktualizaci firmware a OS.'
            }
        ];

        function getRolePermissions(role) {
            return ROLE_PERMISSIONS[role] || ROLE_PERMISSIONS.readonly;
        }

        function canViewSensitive() {
            return getRolePermissions(currentUserRole).viewSensitive;
        }

        function getSensitiveValue(value) {
            return canViewSensitive() ? value : 'Skryto';
        }

        function canEditTopology() {
            return getRolePermissions(currentUserRole).editTopology;
        }

        function canManageRacks() {
            return getRolePermissions(currentUserRole).manageRacks;
        }

        function canManageDevices() {
            return getRolePermissions(currentUserRole).manageDevices;
        }

        function canManageCategories() {
            return getRolePermissions(currentUserRole).manageCategories;
        }

        function canManageRoles() {
            return getRolePermissions(currentUserRole).manageRoles;
        }

        function canDeleteRacks() {
            return getRolePermissions(currentUserRole).deleteRacks;
        }

        function updateRoleLabel() {
            const roleLabel = document.getElementById('userRole');
            if (roleLabel) {
                const label = ROLE_LABELS[currentUserRole] || ROLE_LABELS.readonly;
                roleLabel.textContent = `Role: ${label}`;
            }
        }

        function normalizeEmailKey(email) {
            return (email || '').trim().toLowerCase().replace(/\./g, '_');
        }

        function applyRolePermissions() {
            const addRackBtn = document.getElementById('addRackBtn');
            const clearRacksBtn = document.getElementById('clearRacksBtn');
            const addDeviceBtn = document.getElementById('addDeviceBtn');
            const addConnectionBtn = document.getElementById('addConnectionBtn');
            const moduleButtons = document.querySelectorAll('[onclick="openModuleModal()"]');
            const roleManagerBtn = document.getElementById('roleManagerBtn');

            moduleButtons.forEach((button) => {
                button.disabled = !canManageCategories();
            });
            if (roleManagerBtn) {
                roleManagerBtn.disabled = !canManageRoles();
            }

            if (!currentClientId) {
                disableControls();
                return;
            }

            if (addRackBtn) addRackBtn.disabled = !canManageRacks();
            if (clearRacksBtn) clearRacksBtn.disabled = !canDeleteRacks();
            if (addDeviceBtn) addDeviceBtn.disabled = !canManageDevices();
            if (addConnectionBtn) addConnectionBtn.disabled = !canEditTopology();
        }

        function setCurrentRole(role) {
            currentUserRole = ROLE_PERMISSIONS[role] ? role : 'readonly';
            updateRoleLabel();
            applyRolePermissions();
        }

        async function fetchUserRole() {
            if (!currentClientId || !window.auth || !window.db || !auth.currentUser) {
                setCurrentRole('readonly');
                return;
            }

            try {
                const uid = auth.currentUser.uid;
                const userRef = db.ref(`clients/${currentClientId}/users/${uid}`);
                const usersRef = db.ref(`clients/${currentClientId}/users`);
                const [userSnap, usersSnap] = await Promise.all([
                    userRef.once('value'),
                    usersRef.once('value')
                ]);

                const existing = userSnap.exists() ? userSnap.val() : {};
                let role = existing && existing.role ? existing.role : 'readonly';

                if (!usersSnap.exists()) {
                    role = 'admin';
                }

                if ((!existing || !existing.role) && auth.currentUser.email) {
                    const emailKey = normalizeEmailKey(auth.currentUser.email);
                    const inviteSnap = await db.ref(`clients/${currentClientId}/roleInvites/${emailKey}`).once('value');
                    if (inviteSnap.exists() && inviteSnap.val().role) {
                        role = inviteSnap.val().role;
                    }
                }

                await userRef.update({
                    role: role,
                    email: auth.currentUser.email || '',
                    name: auth.currentUser.displayName || '',
                    updatedAt: new Date().toISOString()
                });

                setCurrentRole(role);
            } catch (err) {
                console.warn('Role fetch failed:', err);
                setCurrentRole('readonly');
            }
        }

        window.onAuthRoleChanged = function (user) {
            if (user && currentClientId) {
                fetchUserRole();
            } else {
                setCurrentRole('readonly');
            }
        };

        async function openRoleManagerModal() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            if (!canManageRoles()) {
                alert('Nemate opravneni spravovat role');
                return;
            }
            await loadRoleManagerList();
            document.getElementById('roleManagerModal').classList.add('active');
        }

        function closeRoleManagerModal() {
            document.getElementById('roleManagerModal').classList.remove('active');
        }

        async function loadRoleManagerList() {
            if (!window.db || !currentClientId) return;
            try {
                const [usersSnap, invitesSnap] = await Promise.all([
                    db.ref(`clients/${currentClientId}/users`).once('value'),
                    db.ref(`clients/${currentClientId}/roleInvites`).once('value')
                ]);
                const users = usersSnap.exists() ? usersSnap.val() : {};
                const invites = invitesSnap.exists() ? invitesSnap.val() : {};
                renderRoleManagerList(users, invites);
            } catch (err) {
                console.warn('Role list load failed:', err);
            }
        }

        async function addRoleInvite() {
            if (!canManageRoles()) {
                alert('Nemate opravneni spravovat role');
                return;
            }
            if (!window.db || !currentClientId) return;

            const emailInput = document.getElementById('roleInviteEmail');
            const roleSelect = document.getElementById('roleInviteRole');
            const email = emailInput ? emailInput.value.trim().toLowerCase() : '';
            const role = roleSelect ? roleSelect.value : 'readonly';

            if (!email || !email.includes('@')) {
                alert('Zadejte platny email');
                return;
            }

            const safeRole = ROLE_PERMISSIONS[role] ? role : 'readonly';
            const emailKey = normalizeEmailKey(email);

            try {
                await db.ref(`clients/${currentClientId}/roleInvites/${emailKey}`).set({
                    email: email,
                    role: safeRole,
                    invitedAt: new Date().toISOString()
                });
                if (emailInput) emailInput.value = '';
                await loadRoleManagerList();
            } catch (err) {
                console.warn('Role invite failed:', err);
            }
        }

        async function removeRoleInvite(emailKey) {
            if (!canManageRoles()) {
                alert('Nemate opravneni spravovat role');
                return;
            }
            if (!window.db || !currentClientId) return;
            try {
                await db.ref(`clients/${currentClientId}/roleInvites/${emailKey}`).remove();
                await loadRoleManagerList();
            } catch (err) {
                console.warn('Role invite remove failed:', err);
            }
        }

        function renderRoleManagerList(users, invites) {
            const container = document.getElementById('roleManagerList');
            if (!container) return;
            const entries = Object.entries(users || {});
            const inviteEntries = Object.entries(invites || {});

            const roleOptions = Object.keys(ROLE_LABELS)
                .map((role) => `<option value="${role}">${ROLE_LABELS[role]}</option>`)
                .join('');

            const userRows = entries.map(([uid, user]) => {
                const email = user.email || uid;
                const name = user.name || '';
                return `
                    <tr>
                        <td>${name || '-'}</td>
                        <td>${email}</td>
                        <td>
                            <select class="role-select" onchange="updateUserRole('${uid}', this.value)">
                                ${roleOptions}
                            </select>
                        </td>
                    </tr>
                `;
            });

            const inviteRows = inviteEntries.map(([emailKey, invite]) => {
                return `
                    <tr>
                        <td>${invite.email || emailKey}</td>
                        <td>${ROLE_LABELS[invite.role] || invite.role || 'Read-only'}</td>
                        <td>
                            <button class="delete-btn" onclick="removeRoleInvite('${emailKey}')">Odebrat</button>
                        </td>
                    </tr>
                `;
            });

            const userTable = entries.length
                ? `
                    <table class="role-manager-table">
                        <thead>
                            <tr>
                                <th>Uzivatel</th>
                                <th>Email / UID</th>
                                <th>Role</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${userRows.join('')}
                        </tbody>
                    </table>
                `
                : '<div class="empty-state"><p>Zadni uzivatele</p></div>';

            const inviteTable = inviteEntries.length
                ? `
                    <div class="role-invite-list">
                        <div class="role-note">Pozvanky</div>
                        <table class="role-manager-table">
                            <thead>
                                <tr>
                                    <th>Email</th>
                                    <th>Role</th>
                                    <th>Akce</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${inviteRows.join('')}
                            </tbody>
                        </table>
                    </div>
                `
                : '';

            container.innerHTML = userTable + inviteTable;

            entries.forEach(([uid, user], index) => {
                const select = container.querySelectorAll('.role-select')[index];
                if (select) {
                    select.value = user.role || 'readonly';
                }
            });
        }

        async function updateUserRole(uid, role) {
            if (!canManageRoles()) {
                alert('Nemate opravneni spravovat role');
                return;
            }
            if (!window.db || !currentClientId) return;
            try {
                const safeRole = ROLE_PERMISSIONS[role] ? role : 'readonly';
                await db.ref(`clients/${currentClientId}/users/${uid}`).update({
                    role: safeRole,
                    updatedAt: new Date().toISOString()
                });
                if (auth && auth.currentUser && uid === auth.currentUser.uid) {
                    setCurrentRole(safeRole);
                }
            } catch (err) {
                console.warn('Role update failed:', err);
            }
        }

        function renderMspModules() {
            const grid = document.getElementById('mspModulesGrid');
            if (!grid) return;

            const cards = mspModules.map((module) => {
                const statusLabel = module.status === 'active' ? 'Active' : 'Planned';
                return `
                    <div class="msp-module-card">
                        <div class="msp-module-meta">${module.category}</div>
                        <div class="msp-module-title">${module.name}</div>
                        <div class="msp-module-desc">${module.description}</div>
                        <div class="msp-module-status">${statusLabel}</div>
                    </div>
                `;
            });

            grid.innerHTML = cards.join('');
        }

        function renderClientOverview() {
            const grid = document.getElementById('overviewGrid');
            const name = document.getElementById('overviewClientName');
            if (!grid) return;

            const client = clients.find((c) => c.id === currentClientId);
            if (name) {
                name.textContent = client ? client.name : '-';
            }

            const totalUnits = racks.reduce((sum, rack) => sum + rack.units, 0);
            const usedUnits = devices.reduce((sum, device) => sum + device.height, 0);
            const freeUnits = Math.max(totalUnits - usedUnits, 0);

            const cards = [
                {
                    title: 'Racky',
                    value: racks.length,
                    desc: 'Sprava fyzickych racku',
                    view: 'racks'
                },
                {
                    title: 'Zarizeni',
                    value: devices.length,
                    desc: 'Aktivni inventar zarizeni',
                    view: 'racks'
                },
                {
                    title: 'Propojeni',
                    value: connections.length,
                    desc: 'Topologie a linky',
                    view: 'network'
                },
                {
                    title: 'Volne U',
                    value: freeUnits,
                    desc: 'Kapacita pro rozsireni',
                    view: 'racks'
                }
            ];

            grid.innerHTML = cards.map((card) => `
                <div class="overview-card" onclick="switchView('${card.view}')">
                    <div class="overview-card-title">${card.title}</div>
                    <div class="overview-card-value">${card.value}</div>
                    <div class="overview-card-desc">${card.desc}</div>
                </div>
            `).join('');

            renderMspModules();
        }

        async function syncZabbixClients() {
            try {
                const response = await fetch('/api/zabbix-hostgroups');
                if (!response.ok) {
                    console.warn('Zabbix sync failed:', response.status);
                    return;
                }
                const data = await response.json();
                if (!data || !Array.isArray(data.groups)) return;

                const zabbixClients = data.groups.map((group) => ({
                    id: `zbx-${group.id}`,
                    name: group.name,
                    type: 'zabbix',
                    source: 'zabbix',
                    createdAt: new Date().toISOString()
                }));

                const manualClients = clients.filter((client) => client.source !== 'zabbix');
                clients = [...manualClients, ...zabbixClients].sort((a, b) =>
                    a.name.localeCompare(b.name, 'cs', { sensitivity: 'base' })
                );
            } catch (err) {
                console.warn('Zabbix sync failed:', err);
            }
        }

        function normalizeModuleId(value) {
            if (!value) return '';
            return value
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
        }

        function hexToRgb(hex) {
            if (!hex) return null;
            let clean = hex.replace('#', '').trim();
            if (clean.length === 3) {
                clean = clean.split('').map((c) => c + c).join('');
            }
            if (clean.length !== 6) return null;
            const num = parseInt(clean, 16);
            if (Number.isNaN(num)) return null;
            return {
                r: (num >> 16) & 255,
                g: (num >> 8) & 255,
                b: num & 255
            };
        }

        function hexToRgba(hex, alpha) {
            const rgb = hexToRgb(hex);
            if (!rgb) return `rgba(248, 154, 85, ${alpha})`;
            return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
        }

        function darkenColor(hex, percent) {
            const rgb = hexToRgb(hex);
            if (!rgb) return '#64748b';
            const factor = Math.max(0, Math.min(1, 1 - percent / 100));
            const r = Math.round(rgb.r * factor);
            const g = Math.round(rgb.g * factor);
            const b = Math.round(rgb.b * factor);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function getContrastColor(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return '#000000';
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            return brightness > 160 ? '#000000' : '#ffffff';
        }

        function loadModuleTypes() {
            const saved = localStorage.getItem('rackManagerModuleTypes');
            customModuleTypes = saved ? JSON.parse(saved) : [];
            const merged = [...DEFAULT_MODULE_TYPES, ...customModuleTypes];
            const seen = new Set();
            moduleTypes = merged.filter((type) => {
                if (!type || !type.id || seen.has(type.id)) return false;
                seen.add(type.id);
                return true;
            });
        }

        function saveModuleTypes() {
            localStorage.setItem('rackManagerModuleTypes', JSON.stringify(customModuleTypes));
        }

        function getModuleType(typeId) {
            return moduleTypes.find((type) => type.id === typeId) || null;
        }

        function getModuleTypeLabel(typeId) {
            const type = getModuleType(typeId);
            return type ? type.label : typeId;
        }

        function getModuleTypeColors(typeId) {
            const type = getModuleType(typeId);
            const base = type && type.color ? type.color : '#94a3b8';
            const gradient = type && type.gradient ? type.gradient : [base, darkenColor(base, 30)];
            const text = type && type.text ? type.text : getContrastColor(base);
            const label = type && type.label ? type.label : typeId;
            const group = type && type.group ? type.group : 'Other';
            return { base, gradient, text, label, group };
        }

        function getModuleStyleVars(typeId) {
            const colors = getModuleTypeColors(typeId);
            return `--device-color: ${colors.base}; --device-gradient: linear-gradient(90deg, ${colors.gradient[0]}, ${colors.gradient[1]}); --device-text: ${colors.text};`;
        }

        function getModuleBadgeVars(typeId) {
            const colors = getModuleTypeColors(typeId);
            return `--badge-bg: ${hexToRgba(colors.base, 0.2)}; --badge-border: ${hexToRgba(colors.base, 0.5)}; --badge-color: ${colors.base};`;
        }

        function renderDeviceTypeOptions(selectedId) {
            const select = document.getElementById('deviceType');
            if (!select) return;
            const current = selectedId || select.value;
            if (!moduleTypes.length) {
                select.innerHTML = '<option value="">Zadne kategorie</option>';
                return;
            }
            select.innerHTML = moduleTypes.map((type) => {
                return `<option value="${type.id}">${type.label}</option>`;
            }).join('');
            const fallback = moduleTypes[0].id;
            select.value = moduleTypes.some((type) => type.id === current) ? current : fallback;
        }

        function renderModuleList() {
            const list = document.getElementById('moduleList');
            if (!list) return;
            const customIds = new Set(customModuleTypes.map((type) => type.id));
            const items = moduleTypes.map((type) => {
                const colors = getModuleTypeColors(type.id);
                const isCustom = customIds.has(type.id);
                const action = isCustom
                    ? `<button class="delete-btn" onclick="deleteModuleType('${type.id}')">Smazat</button>`
                    : `<span class="module-id">system</span>`;
                return `
                    <div class="module-item">
                        <div class="module-meta">
                            <span class="module-color" style="background: ${colors.base};"></span>
                            <span>${type.label}</span>
                            <span class="module-id">${type.id}</span>
                            <span class="module-id">${type.group || 'Other'}</span>
                        </div>
                        ${action}
                    </div>
                `;
            });
            list.innerHTML = items.join('') || '<div class="empty-state"><p>Zadne kategorie</p></div>';
        }

        function clearModuleForm() {
            document.getElementById('moduleName').value = '';
            document.getElementById('moduleId').value = '';
            document.getElementById('moduleGroup').value = 'Network';
            document.getElementById('moduleColor').value = '#00ff88';
        }

        function openModuleModal() {
            if (!canManageCategories()) {
                alert('Nemate opravneni spravovat kategorie');
                return;
            }
            loadModuleTypes();
            renderModuleList();
            renderDeviceTypeOptions();
            document.getElementById('moduleModal').classList.add('active');
        }

        function closeModuleModal() {
            document.getElementById('moduleModal').classList.remove('active');
            clearModuleForm();
        }

        function addModuleType() {
            if (!canManageCategories()) {
                alert('Nemate opravneni spravovat kategorie');
                return;
            }
            const name = document.getElementById('moduleName').value.trim();
            const rawId = document.getElementById('moduleId').value.trim();
            const group = document.getElementById('moduleGroup').value;
            const color = document.getElementById('moduleColor').value || '#00ff88';

            if (!name) {
                alert('Nazev kategorie je povinny');
                return;
            }

            const id = normalizeModuleId(rawId || name);
            if (!id) {
                alert('ID kategorie je neplatne');
                return;
            }

            if (moduleTypes.some((type) => type.id === id)) {
                alert('Kategorie s timto ID uz existuje');
                return;
            }

            customModuleTypes.push({
                id,
                label: name,
                color,
                gradient: [color, darkenColor(color, 30)],
                text: getContrastColor(color),
                group
            });

            saveModuleTypes();
            loadModuleTypes();
            renderDeviceTypeOptions(id);
            renderModuleList();
            clearModuleForm();
        }

        function deleteModuleType(id) {
            if (!canManageCategories()) {
                alert('Nemate opravneni spravovat kategorie');
                return;
            }
            const inUse = devices.some((device) => device.type === id);
            if (inUse && !confirm('Kategorie je pouzita v zarizenich. Pokracovat?')) {
                return;
            }
            customModuleTypes = customModuleTypes.filter((type) => type.id !== id);
            saveModuleTypes();
            loadModuleTypes();
            renderDeviceTypeOptions();
            renderModuleList();
        }
        
        // Initialize from localStorage
        async function init() {
            // Load clients
            const savedClients = localStorage.getItem('rackManagerClients');
            if (savedClients) {
                clients = JSON.parse(savedClients);
            }
            
            // Load all client data
            const savedClientData = localStorage.getItem('rackManagerClientData');
            if (savedClientData) {
                clientData = JSON.parse(savedClientData);
            }
            
            // Check if there was a previously selected client
            const lastClientId = localStorage.getItem('rackManagerLastClient');
            if (lastClientId && clients.find(c => c.id === lastClientId)) {
                currentClientId = lastClientId;
                loadClientData(currentClientId);
            }
            
            loadModuleTypes();
            renderDeviceTypeOptions();
            await syncZabbixClients();
            updateClientSelector();
            render();
            fetchUserRole();
        }
        
        // Save data to localStorage
        function saveData() {
            // Save current client's data
            if (currentClientId) {
                clientData[currentClientId] = {
                    racks,
                    devices,
                    connections
                };
            }
            
            localStorage.setItem('rackManagerClients', JSON.stringify(clients));
            localStorage.setItem('rackManagerClientData', JSON.stringify(clientData));
            if (currentClientId) {
                localStorage.setItem('rackManagerLastClient', currentClientId);
            }
        }
        
        // Load data for specific client
        function loadClientData(clientId) {
            if (clientData[clientId]) {
                racks = clientData[clientId].racks || [];
                devices = clientData[clientId].devices || [];
                connections = clientData[clientId].connections || [];
            } else {
                racks = [];
                devices = [];
                connections = [];
            }
        }
        
        // Switch client
        function switchClient() {
            const selector = document.getElementById('clientSelector');
            const clientId = selector.value;
            
            if (!clientId) {
                currentClientId = null;
                racks = [];
                devices = [];
                connections = [];
                document.getElementById('clientInfo').style.display = 'none';
                disableControls();
                render();
                return;
            } else {
                currentClientId = clientId;
                loadClientData(clientId);
                updateClientInfo();
                enableControls();
            }
            render();
            fetchUserRole();
            switchView('overview');
        }
        
        // Update client selector
        function updateClientSelector() {
            const selector = document.getElementById('clientSelector');
            selector.innerHTML = '<option value="">-- Vyberte klienta --</option>' + 
                clients.map(client => 
                    `<option value="${client.id}" ${client.id === currentClientId ? 'selected' : ''}>${client.name}</option>`
                ).join('');
        }
        
        // Update client info panel
        function updateClientInfo() {
            const client = clients.find(c => c.id === currentClientId);
            if (client) {
                document.getElementById('clientInfo').style.display = 'block';
                document.getElementById('clientName').textContent = client.name + (client.ico ? ` (ICO: ${client.ico})` : '');
                updateRoleLabel();
                document.getElementById('clientContact').textContent = client.contact ? `Kontakt: ${client.contact}` : '';
                document.getElementById('clientLocation').textContent = client.address ? `Adresa: ${client.address}` : '';
                document.getElementById('clientType').textContent = client.type.toUpperCase();
            } else {
                document.getElementById('clientInfo').style.display = 'none';
            }
        }
        
        // Enable/disable controls
        function enableControls() {
            applyRolePermissions();
        }
        
        function disableControls() {
            document.getElementById('addRackBtn').disabled = true;
            document.getElementById('clearRacksBtn').disabled = true;
            document.getElementById('addDeviceBtn').disabled = true;
            document.getElementById('addConnectionBtn').disabled = true;
        }
        
        // View switching
        function switchView(view, button) {
            // Update toggle buttons
            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeButton = button || document.querySelector(`.view-toggle-btn[data-view="${view}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
            
            // Hide all views
            document.getElementById('racksView').style.display = 'none';
            document.getElementById('networkView').style.display = 'none';
            document.getElementById('topologyView').style.display = 'none';
            document.getElementById('overviewView').style.display = 'none';
            
            // Show selected view
            switch(view) {
                case 'racks':
                    document.getElementById('racksView').style.display = 'block';
                    break;
                case 'network':
                    document.getElementById('networkView').style.display = 'block';
                    initNetworkVisualization();
                    break;
                case 'topology':
                    document.getElementById('topologyView').style.display = 'block';
                    renderTopologyView();
                    break;
                case 'overview':
                    document.getElementById('overviewView').style.display = 'block';
                    renderClientOverview();
                    break;
            }
        }
        
        // Network Visualization
        let networkCanvas, networkCtx;
        let networkNodes = [];
        let networkEdges = [];
        let isDragging = false;
        let dragNode = null;
        let offsetX, offsetY;
        
        function initNetworkVisualization() {
            if (!currentClientId) return;
            
            networkCanvas = document.getElementById('networkCanvas');
            if (!networkCanvas) return;
            
            networkCtx = networkCanvas.getContext('2d');
            
            // Set canvas size
            networkCanvas.width = networkCanvas.clientWidth;
            networkCanvas.height = 500;
            
            // Build network data
            buildNetworkData();
            
            // Draw network
            drawNetwork();
            
            // Update stats
            updateNetworkStats();
            
            // Add event listeners
            networkCanvas.addEventListener('mousedown', handleNetworkMouseDown);
            networkCanvas.addEventListener('mousemove', handleNetworkMouseMove);
            networkCanvas.addEventListener('mouseup', handleNetworkMouseUp);
            networkCanvas.addEventListener('dblclick', handleNetworkDoubleClick);
        }
        
        function buildNetworkData() {
            networkNodes = [];
            networkEdges = [];
            
            // Create nodes for each device
            devices.forEach((device, index) => {
                const angle = (index / devices.length) * Math.PI * 2;
                const radius = 150;
                const centerX = networkCanvas.width / 2;
                const centerY = networkCanvas.height / 2;
                
                networkNodes.push({
                    id: device.id,
                    name: device.name,
                    type: device.type,
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    ports: device.ports || 24,
                    device: device
                });
            });
            
            // Create edges for connections
            connections.forEach(conn => {
                const fromNode = networkNodes.find(n => n.id === conn.fromDevice);
                const toNode = networkNodes.find(n => n.id === conn.toDevice);
                
                if (fromNode && toNode) {
                    networkEdges.push({
                        from: fromNode,
                        to: toNode,
                        connection: conn
                    });
                }
            });
        }
        
        function drawNetwork() {
            if (!networkCtx) return;
            
            // Clear canvas
            networkCtx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);
            
            // Draw edges
            networkEdges.forEach(edge => {
                networkCtx.beginPath();
                networkCtx.moveTo(edge.from.x, edge.from.y);
                networkCtx.lineTo(edge.to.x, edge.to.y);
                
                // Style based on connection type
                if (edge.connection.type === 'trunk') {
                    networkCtx.strokeStyle = '#ff00ff';
                    networkCtx.lineWidth = 3;
                } else if (edge.connection.type === 'uplink') {
                    networkCtx.strokeStyle = '#00ffff';
                    networkCtx.lineWidth = 4;
                } else {
                    networkCtx.strokeStyle = '#00ff88';
                    networkCtx.lineWidth = 2;
                }
                
                networkCtx.stroke();
                
                // Draw speed label
                const midX = (edge.from.x + edge.to.x) / 2;
                const midY = (edge.from.y + edge.to.y) / 2;
                networkCtx.fillStyle = '#ffffff';
                networkCtx.font = '10px IBM Plex Mono';
                networkCtx.textAlign = 'center';
                const speed = edge.connection.speed >= 1000 ? 
                    (edge.connection.speed / 1000) + 'G' : 
                    edge.connection.speed + 'M';
                networkCtx.fillText(speed, midX, midY - 5);
            });
            
            // Draw nodes
            networkNodes.forEach(node => {
                const nodeColors = getModuleTypeColors(node.type);

                // Node circle
                networkCtx.beginPath();
                networkCtx.arc(node.x, node.y, 30, 0, Math.PI * 2);
                networkCtx.fillStyle = nodeColors.base;
                networkCtx.fill();
                networkCtx.strokeStyle = '#ffffff';
                networkCtx.lineWidth = 2;
                networkCtx.stroke();
                
                // Node label
                networkCtx.fillStyle = nodeColors.text;
                networkCtx.font = 'bold 12px IBM Plex Mono';
                networkCtx.textAlign = 'center';
                networkCtx.fillText(node.name, node.x, node.y + 5);
                
                // Port count
                networkCtx.fillStyle = nodeColors.text;
                networkCtx.font = '10px IBM Plex Mono';
                networkCtx.fillText(node.ports + ' ports', node.x, node.y + 45);
            });
        }
        
        function handleNetworkMouseDown(e) {
            if (!canEditTopology()) {
                return;
            }
            const rect = networkCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on a node
            networkNodes.forEach(node => {
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= 30) {
                    isDragging = true;
                    dragNode = node;
                    offsetX = dx;
                    offsetY = dy;
                    networkCanvas.style.cursor = 'grabbing';
                }
            });
        }
        
        function handleNetworkMouseMove(e) {
            if (isDragging && dragNode) {
                const rect = networkCanvas.getBoundingClientRect();
                dragNode.x = e.clientX - rect.left - offsetX;
                dragNode.y = e.clientY - rect.top - offsetY;
                drawNetwork();
            }
        }
        
        function handleNetworkMouseUp() {
            isDragging = false;
            dragNode = null;
            networkCanvas.style.cursor = 'grab';
        }
        
        function handleNetworkDoubleClick(e) {
            const rect = networkCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if double-clicking on a node
            networkNodes.forEach(node => {
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= 30) {
                    showPortDetails(node.device);
                }
            });
        }
        
        function resetNetworkView() {
            buildNetworkData();
            drawNetwork();
        }
        
        function exportNetworkDiagram() {
            const link = document.createElement('a');
            link.download = 'network-diagram.png';
            link.href = networkCanvas.toDataURL();
            link.click();
        }
        
        function updateNetworkStats() {
            const totalPortsCount = devices.reduce((sum, d) => sum + (d.ports || 24), 0);
            const usedPortsCount = connections.length * 2; // Each connection uses 2 ports
            const trunkPortsCount = connections.filter(c => c.type === 'trunk').length * 2;
            
            document.getElementById('totalConnections').textContent = connections.length;
            document.getElementById('totalPorts').textContent = totalPortsCount;
            document.getElementById('usedPorts').textContent = usedPortsCount;
            document.getElementById('trunkPorts').textContent = trunkPortsCount;
        }
        
        // Port Management
        function showPortDetails(device) {
            document.getElementById('portDetailsOverlay').classList.add('active');
            document.getElementById('portDetailsTitle').textContent = device.name + ' - Port Management';
            
            const content = document.getElementById('portDetailsContent');
            const portCount = device.ports || 24;
            
            // Get connections for this device
            const deviceConnections = connections.filter(c => 
                c.fromDevice === device.id || c.toDevice === device.id
            );
            
            let html = `
                <div class="port-grid">
            `;
            
            for (let i = 1; i <= portCount; i++) {
                const conn = deviceConnections.find(c => 
                    (c.fromDevice === device.id && c.fromPort === i) ||
                    (c.toDevice === device.id && c.toPort === i)
                );
                
                let portClass = 'port-item';
                let portLabel = '';
                
                if (conn) {
                    portClass += ' connected';
                    if (conn.type === 'trunk') portClass += ' trunk';
                    if (conn.type === 'uplink') portClass += ' uplink';
                    
                    // Find connected device
                    const connectedDeviceId = conn.fromDevice === device.id ? 
                        conn.toDevice : conn.fromDevice;
                    const connectedDevice = devices.find(d => d.id === connectedDeviceId);
                    portLabel = connectedDevice ? connectedDevice.name : 'Connected';
                }
                
                html += `
                    <div class="${portClass}" onclick="configurePort('${device.id}', ${i})">
                        <div class="port-number">${i}</div>
                        ${portLabel ? `<div class="port-label">${portLabel}</div>` : ''}
                        ${conn && conn.vlans ? `<div class="vlan-tag">VLAN ${conn.vlans}</div>` : ''}
                    </div>
                `;
            }
            
            html += `
                </div>
                <div style="margin-top: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Aktivn칤 propojen칤</h3>
            `;
            
            if (deviceConnections.length > 0) {
                deviceConnections.forEach(conn => {
                    const otherDeviceId = conn.fromDevice === device.id ? 
                        conn.toDevice : conn.fromDevice;
                    const otherDevice = devices.find(d => d.id === otherDeviceId);
                    const fromPort = conn.fromDevice === device.id ? conn.fromPort : conn.toPort;
                    const toPort = conn.fromDevice === device.id ? conn.toPort : conn.fromPort;
                    
                    html += `
                        <div class="connection-path">
                            <div class="connection-path-device">${device.name}:${fromPort}</div>
                            <div class="connection-path-arrow"></div>
                            <div class="connection-path-device">${otherDevice ? otherDevice.name : 'Unknown'}:${toPort}</div>
                            <div style="margin-left: auto;">
                                <span class="connection-path-port">
                                    ${conn.type} | ${conn.speed >= 1000 ? (conn.speed/1000) + 'G' : conn.speed + 'M'}
                                    ${conn.description ? ' | ' + conn.description : ''}
                                </span>
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<p style="color: var(--text-secondary);">콯치dn치 aktivn칤 propojen칤</p>';
            }
            
            html += '</div>';
            
            content.innerHTML = html;
        }
        
        function closePortDetails() {
            document.getElementById('portDetailsOverlay').classList.remove('active');
        }
        
        function configurePort(deviceId, portNumber) {
            // Here you could open a modal to configure specific port
            console.log('Configure port', portNumber, 'on device', deviceId);
        }
        
        // Connection Management
        function openConnectionModal() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            if (!canEditTopology()) {
                alert('Nemate opravneni upravovat topologii');
                return;
            }
            if (devices.length < 2) {
                alert('Pro vytvoreni propojeni potrebujete alespon 2 zarizeni');
                return;
            }

            const deviceOptions = devices.map(d => 
                `<option value="${d.id}">${d.name} (${d.type})</option>`
            ).join('');

            document.getElementById('connFromDevice').innerHTML = deviceOptions;
            document.getElementById('connToDevice').innerHTML = deviceOptions;

            updateFromPorts();
            updateToPorts();

            document.getElementById('connectionModal').classList.add('active');
        }
        
        function closeConnectionModal() {
            document.getElementById('connectionModal').classList.remove('active');
            clearConnectionForm();
        }
        
        function updateFromPorts() {
            const deviceId = document.getElementById('connFromDevice').value;
            const device = devices.find(d => d.id === deviceId);
            const portCount = device ? (device.ports || 24) : 24;
            
            let options = '';
            for (let i = 1; i <= portCount; i++) {
                // Check if port is already used
                const isUsed = connections.some(c => 
                    (c.fromDevice === deviceId && c.fromPort === i) ||
                    (c.toDevice === deviceId && c.toPort === i)
                );
                
                if (!isUsed) {
                    options += `<option value="${i}">Port ${i}</option>`;
                }
            }
            
            document.getElementById('connFromPort').innerHTML = options || '<option>V코echny porty obsazeny</option>';
        }
        
        function updateToPorts() {
            const deviceId = document.getElementById('connToDevice').value;
            const device = devices.find(d => d.id === deviceId);
            const portCount = device ? (device.ports || 24) : 24;
            
            let options = '';
            for (let i = 1; i <= portCount; i++) {
                // Check if port is already used
                const isUsed = connections.some(c => 
                    (c.fromDevice === deviceId && c.fromPort === i) ||
                    (c.toDevice === deviceId && c.toPort === i)
                );
                
                if (!isUsed) {
                    options += `<option value="${i}">Port ${i}</option>`;
                }
            }
            
            document.getElementById('connToPort').innerHTML = options || '<option>V코echny porty obsazeny</option>';
        }
        
        function addConnection() {
            if (!canEditTopology()) {
                alert('Nemate opravneni upravovat topologii');
                return;
            }
            const fromDevice = document.getElementById('connFromDevice').value;
            const fromPort = parseInt(document.getElementById('connFromPort').value);
            const toDevice = document.getElementById('connToDevice').value;
            const toPort = parseInt(document.getElementById('connToPort').value);
            const type = document.getElementById('connType').value;
            const vlans = document.getElementById('connVlans').value;
            const speed = parseInt(document.getElementById('connSpeed').value);
            const description = document.getElementById('connDescription').value;

            if (!fromDevice || !toDevice || !fromPort || !toPort) {
                alert('Vyplnte vsechny povinne udaje');
                return;
            }

            if (fromDevice === toDevice) {
                alert('Nelze propojit zarizeni samo se sebou');
                return;
            }

            const connection = {
                id: Date.now().toString(),
                fromDevice,
                fromPort,
                toDevice,
                toPort,
                type,
                vlans,
                speed,
                description,
                createdAt: new Date().toISOString()
            };

            connections.push(connection);
            saveData();
            render();
            closeConnectionModal();
        }
        
        function clearConnectionForm() {
            document.getElementById('connFromPort').value = '';
            document.getElementById('connToPort').value = '';
            document.getElementById('connType').value = 'access';
            document.getElementById('connVlans').value = '';
            document.getElementById('connSpeed').value = '1000';
            document.getElementById('connDescription').value = '';
        }
        
        // Render topology view
        function renderTopologyView() {
            const container = document.getElementById('topologyView');
            
            if (!currentClientId) {
                container.innerHTML = `
                    <div class="no-client-warning">
                        <div class="empty-state-icon">丘멆잺</div>
                        <p><strong>Nejprve vyberte klienta</strong><br>
                        Pro zobrazen칤 topologie mus칤te vybrat klienta z horn칤ho menu.</p>
                    </div>
                `;
                return;
            }
            
            if (devices.length === 0) {
                container.innerHTML = `
                    <div class="rack-container">
                        <div class="empty-state">
                            <div class="empty-state-icon">游댕</div>
                            <p>콯치dn치 za콏칤zen칤 k zobrazen칤 topologie</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Group devices by module type
            const groups = moduleTypes.map((type) => ({
                type,
                devices: devices.filter((device) => device.type === type.id)
            })).filter((group) => group.devices.length > 0);

            const unknownDevices = devices.filter((device) =>
                !moduleTypes.some((type) => type.id === device.type)
            );
            if (unknownDevices.length > 0) {
                groups.push({
                    type: { id: 'other', label: 'Other', color: '#94a3b8', group: 'Other' },
                    devices: unknownDevices
                });
            }

            let html = `
                <div class="rack-container">
                    <h2>Sitova topologie</h2>
                    <div style="display: grid; gap: 2rem; margin-top: 2rem;">
            `;

            groups.forEach((group) => {
                const colors = getModuleTypeColors(group.type.id);
                const heading = group.type.group ? `${group.type.group} - ${group.type.label}` : group.type.label;

                html += `
                    <div class="topology-group" style="border-color: ${colors.base};">
                        <h3 style="color: ${colors.base}; margin-bottom: 1rem;">${heading}</h3>
                        <div class="topology-group-grid">
                `;

                group.devices.forEach((device) => {
                    const label = getModuleTypeLabel(device.type);
                    html += `
                        <div class="client-card" style="cursor: pointer;" onclick="showPortDetails(devices.find(d => d.id === '${device.id}'))">
                            <div style="font-weight: 600; color: ${colors.base};">${device.name}</div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">
                                ${getSensitiveValue(device.ip || 'No IP')} | ${device.ports || 24} ports
                            </div>
                            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: ${colors.base};">${label}</div>
                        </div>
                    `;
                });

                html += '</div></div>';
            });

            if (groups.length === 0) {
                html += `
                    <div class="topology-group">
                        <p>No devices to display</p>
                    </div>
                `;
            }

            html += '</div></div>';
            container.innerHTML = html;
        }
        
        // Client management functions
        function openClientModal() {
            document.getElementById('clientModal').classList.add('active');
        }
        
        function closeClientModal() {
            document.getElementById('clientModal').classList.remove('active');
            clearClientForm();
        }
        
        function openClientManagerModal() {
            renderClientList();
            document.getElementById('clientManagerModal').classList.add('active');
        }
        
        function closeClientManagerModal() {
            document.getElementById('clientManagerModal').classList.remove('active');
        }
        
        function clearClientForm() {
            document.getElementById('newClientName').value = '';
            document.getElementById('newClientICO').value = '';
            document.getElementById('newClientType').value = 'standard';
            document.getElementById('newClientContact').value = '';
            document.getElementById('newClientEmail').value = '';
            document.getElementById('newClientPhone').value = '';
            document.getElementById('newClientAddress').value = '';
            document.getElementById('newClientNotes').value = '';
        }
        
        function addClient() {
            const name = document.getElementById('newClientName').value;
            const ico = document.getElementById('newClientICO').value;
            const type = document.getElementById('newClientType').value;
            const contact = document.getElementById('newClientContact').value;
            const email = document.getElementById('newClientEmail').value;
            const phone = document.getElementById('newClientPhone').value;
            const address = document.getElementById('newClientAddress').value;
            const notes = document.getElementById('newClientNotes').value;
            
            if (!name) {
                alert('N치zev klienta je povinn칳');
                return;
            }
            
            const client = {
                id: Date.now().toString(),
                name,
                ico,
                type,
                contact,
                email,
                phone,
                address,
                notes,
                createdAt: new Date().toISOString()
            };
            
            clients.push(client);
            saveData();
            updateClientSelector();
            closeClientModal();
            
            // Automatically select the new client
            document.getElementById('clientSelector').value = client.id;
            switchClient();
        }
        
        function deleteClient(clientId) {
            const client = clients.find(c => c.id === clientId);
            if (!client) return;
            
            if (confirm(`Opravdu chcete smazat klienta "${client.name}" v캜etn캩 v코ech jeho dat?`)) {
                // Remove client
                clients = clients.filter(c => c.id !== clientId);
                
                // Remove client data
                delete clientData[clientId];
                
                // If this was the current client, clear selection
                if (currentClientId === clientId) {
                    currentClientId = null;
                    racks = [];
                    devices = [];
                    connections = [];
                }
                
                saveData();
                updateClientSelector();
                render();
                renderClientList();
            }
        }
        
        function renderClientList() {
            const list = document.getElementById('clientList');
            const searchTerm = document.getElementById('clientSearch').value.toLowerCase();
            
            const filteredClients = clients.filter(client => 
                client.name.toLowerCase().includes(searchTerm) ||
                (client.ico && client.ico.includes(searchTerm)) ||
                (client.contact && client.contact.toLowerCase().includes(searchTerm))
            );
            
            if (filteredClients.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>콯치dn칤 klienti nenalezeni</p></div>';
                return;
            }
            
            list.innerHTML = filteredClients.map(client => {
                const data = clientData[client.id] || { racks: [], devices: [] };
                return `
                    <div class="client-card" onclick="selectClientFromList('${client.id}')">
                        <div class="client-card-header">
                            <div class="client-card-name">${client.name}</div>
                            <div class="client-actions" onclick="event.stopPropagation()">
                                <button class="btn-icon danger" onclick="deleteClient('${client.id}')">游딈</button>
                            </div>
                        </div>
                        <div class="client-card-stats">
                            <span>游닍 ${data.racks.length} rack콢</span>
                            <span>游둰勇 ${data.devices.length} za콏칤zen칤</span>
                            <span class="client-badge">${client.type}</span>
                        </div>
                        ${client.contact ? `<div style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-secondary);">游녻 ${client.contact}</div>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        function selectClientFromList(clientId) {
            document.getElementById('clientSelector').value = clientId;
            switchClient();
            closeClientManagerModal();
        }
        
        function searchClients() {
            renderClientList();
        }
        
        // Render all components
        function render() {
            renderRacks();
            renderDeviceTable();
            renderConnections();
            updateStats();
        }
        
        // Render racks
        function renderRacks() {
            const grid = document.getElementById('rackGrid');
            
            if (!currentClientId) {
                grid.innerHTML = `
                    <div class="no-client-warning">
                        <div class="empty-state-icon">丘멆잺</div>
                        <p><strong>Nejprve vyberte klienta</strong><br>
                        Pro zobrazen칤 a spr치vu rack콢 mus칤te vybrat klienta z horn칤ho menu.</p>
                    </div>
                `;
                return;
            }
            
            if (racks.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">游닍</div>
                        <p>Klient ${clients.find(c => c.id === currentClientId)?.name} zat칤m nem치 쮂멳n칠 racky.<br>Klikn캩te na "P콏idat rack" pro vytvo콏en칤 prvn칤ho racku.</p>
                    </div>
                `;
                return;
            }
            
            grid.innerHTML = racks.map(rack => `
                <div class="rack">
                    <div class="rack-title">${rack.name}</div>
                    <div class="rack-units">
                        ${generateRackUnits(rack)}
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">
                        游늸 ${rack.location || 'Neur캜eno'}
                    </div>
                </div>
            `).join('');
            
            // Add event listeners for device hover
            document.querySelectorAll('.rack-unit.occupied').forEach(unit => {
                unit.addEventListener('mouseenter', showDeviceTooltip);
                unit.addEventListener('mouseleave', hideDeviceTooltip);
                unit.addEventListener('click', () => {
                    const deviceId = unit.dataset.deviceId;
                    if (deviceId) {
                        const device = devices.find(d => d.id === deviceId);
                        if (device) {
                            showPortDetails(device);
                        }
                    }
                });
            });
        }
        
        // Generate rack units HTML
        function generateRackUnits(rack) {
            let html = '';
            const rackDevices = devices.filter(d => d.rack === rack.id);
            
            for (let i = 1; i <= rack.units; i++) {
                const device = rackDevices.find(d => 
                    i >= d.position && i < d.position + d.height
                );
                
                if (device) {
                    if (i === device.position) {
                        const moduleStyle = getModuleStyleVars(device.type);
                        html += `<div class="rack-unit occupied ${device.type}" 
                                      data-device-id="${device.id}"
                                      data-device-name="${device.name}"
                                      data-device-type="${device.type}"
                                      data-device-position="U${device.position}"
                                      data-device-ip="${device.ip || 'N/A'}"
                                      data-device-model="${device.model || 'N/A'}"
                                      data-device-serial="${device.serial || 'N/A'}"
                                      style="${moduleStyle} height: ${20 * device.height + 2 * (device.height - 1)}px;">
                                    ${device.name}
                                </div>`;
                    }
                } else {
                    const isPartOfDevice = rackDevices.some(d => 
                        i > d.position && i < d.position + d.height
                    );
                    if (!isPartOfDevice) {
                        html += `<div class="rack-unit">U${i}</div>`;
                    }
                }
            }
            
            return html;
        }
        
        // Show device tooltip
        function showDeviceTooltip(e) {
            const tooltip = document.getElementById('deviceTooltip');
            const unit = e.target;
            
            document.getElementById('tooltipName').textContent = unit.dataset.deviceName;
            document.getElementById('tooltipType').textContent = `Typ: ${getModuleTypeLabel(unit.dataset.deviceType)}`;
            document.getElementById('tooltipPosition').textContent = `Pozice: ${unit.dataset.devicePosition}`;
            document.getElementById('tooltipIP').textContent = `IP: ${getSensitiveValue(unit.dataset.deviceIp)}`;
            document.getElementById('tooltipModel').textContent = `Model: ${unit.dataset.deviceModel}`;
            document.getElementById('tooltipSerial').textContent = `S/N: ${getSensitiveValue(unit.dataset.deviceSerial)}`;
            
            tooltip.classList.add('active');
            
            const rect = unit.getBoundingClientRect();
            tooltip.style.left = rect.right + 10 + 'px';
            tooltip.style.top = rect.top + 'px';
        }
        
        // Hide device tooltip
        function hideDeviceTooltip() {
            document.getElementById('deviceTooltip').classList.remove('active');
        }
        
        // Render device table
        function renderDeviceTable() {
            const container = document.getElementById('deviceListContainer');
            const tbody = document.getElementById('deviceTableBody');
            
            if (devices.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            tbody.innerHTML = devices.map(device => {
                const rack = racks.find(r => r.id === device.rack);
                const typeLabel = getModuleTypeLabel(device.type);
                const badgeStyle = getModuleBadgeVars(device.type);
                const ipValue = getSensitiveValue(device.ip || 'N/A');
                const deleteDisabled = canManageDevices() ? '' : 'disabled';
                return `
                    <tr>
                        <td>${device.name}</td>
                        <td><span class="device-type-badge ${device.type}" style="${badgeStyle}">${typeLabel}</span></td>
                        <td>${rack ? rack.name : 'N/A'}</td>
                        <td>U${device.position}</td>
                        <td>${ipValue}</td>
                        <td>${device.model || 'N/A'}</td>
                        <td>
                            <button class="delete-btn" onclick="deleteDevice('${device.id}')" ${deleteDisabled}>Smazat</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        // Render connections
        function renderConnections() {
            const container = document.getElementById('connectionsContainer');
            const list = document.getElementById('connectionsList');
            
            if (connections.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            list.innerHTML = connections.map(conn => `
                <div class="connection-item">
                    <div class="connection-from">${conn.from}</div>
                    <div class="connection-arrow"></div>
                    <div class="connection-to">${conn.to}</div>
                </div>
            `).join('');
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('totalDevices').textContent = devices.length;
            document.getElementById('totalRacks').textContent = racks.length;
            
            const totalUnits = racks.reduce((sum, rack) => sum + rack.units, 0);
            const usedUnits = devices.reduce((sum, device) => sum + device.height, 0);
            
            document.getElementById('usedUnits').textContent = usedUnits;
            document.getElementById('freeUnits').textContent = totalUnits - usedUnits;
        }
        
        // Modal functions
        function openRackModal() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            if (!canManageRacks()) {
                alert('Nemate opravneni spravovat racky');
                return;
            }
            document.getElementById('rackModal').classList.add('active');
        }
        
        function closeRackModal() {
            document.getElementById('rackModal').classList.remove('active');
            clearRackForm();
        }
        
        function openDeviceModal() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            if (!canManageDevices()) {
                alert('Nemate opravneni spravovat zarizeni');
                return;
            }
            if (racks.length === 0) {
                alert('Nejprve vytvorte rack');
                return;
            }

            const select = document.getElementById('deviceRack');
            select.innerHTML = racks.map(rack => 
                `<option value="${rack.id}">${rack.name}</option>`
            ).join('');

            renderDeviceTypeOptions();
            document.getElementById('deviceModal').classList.add('active');
        }
        
        function closeDeviceModal() {
            document.getElementById('deviceModal').classList.remove('active');
            clearDeviceForm();
        }
        
        // Add rack
        function addRack() {
            if (!canManageRacks()) {
                alert('Nemate opravneni spravovat racky');
                return;
            }
            const name = document.getElementById('rackName').value;
            const units = parseInt(document.getElementById('rackUnits').value);
            const location = document.getElementById('rackLocation').value;
            
            if (!name || !units) {
                alert('Vypl켿te v코echny povinn칠 칰daje');
                return;
            }
            
            const rack = {
                id: Date.now().toString(),
                name,
                units,
                location
            };
            
            racks.push(rack);
            saveData();
            render();
            closeRackModal();
        }
        
        // Add device
        function addDevice() {
            if (!canManageDevices()) {
                alert('Nemate opravneni spravovat zarizeni');
                return;
            }
            const name = document.getElementById('deviceName').value;
            const type = document.getElementById('deviceType').value;
            const rack = document.getElementById('deviceRack').value;
            const position = parseInt(document.getElementById('devicePosition').value);
            const height = parseInt(document.getElementById('deviceHeight').value);
            const ip = document.getElementById('deviceIP').value;
            const model = document.getElementById('deviceModel').value;
            const serial = document.getElementById('deviceSerial').value;
            const ports = parseInt(document.getElementById('devicePorts').value) || 24;
            
            if (!name || !rack || !position) {
                alert('Vypl켿te v코echny povinn칠 칰daje');
                return;
            }
            
            // Check if position is available
            const rackObj = racks.find(r => r.id === rack);
            if (position + height - 1 > rackObj.units) {
                alert('Za콏칤zen칤 se nevejde do racku');
                return;
            }
            
            const existingDevices = devices.filter(d => d.rack === rack);
            for (let device of existingDevices) {
                if ((position >= device.position && position < device.position + device.height) ||
                    (position + height > device.position && position + height <= device.position + device.height)) {
                    alert('Pozice je ji obsazena');
                    return;
                }
            }
            
            const device = {
                id: Date.now().toString(),
                name,
                type,
                rack,
                position,
                height,
                ip,
                model,
                serial,
                ports
            };
            
            devices.push(device);
            saveData();
            render();
            closeDeviceModal();
        }
        
        // Delete device
        function deleteDevice(id) {
            if (!canManageDevices()) {
                alert('Nemate opravneni spravovat zarizeni');
                return;
            }
            if (confirm('Opravdu chcete smazat toto za콏칤zen칤?')) {
                devices = devices.filter(d => d.id !== id);
                connections = connections.filter(c => c.fromDevice !== id && c.toDevice !== id);
                saveData();
                render();
            }
        }
        
        // Clear forms
        function clearRackForm() {
            document.getElementById('rackName').value = '';
            document.getElementById('rackUnits').value = '42';
            document.getElementById('rackLocation').value = '';
        }
        
        function clearDeviceForm() {
            document.getElementById('deviceName').value = '';
            document.getElementById('deviceType').value = moduleTypes.length ? moduleTypes[0].id : '';
            document.getElementById('devicePosition').value = '';
            document.getElementById('deviceHeight').value = '1';
            document.getElementById('deviceIP').value = '';
            document.getElementById('deviceModel').value = '';
            document.getElementById('deviceSerial').value = '';
            document.getElementById('devicePorts').value = '24';
        }
        
        // Clear all data
        function clearAllRacks() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            if (!canDeleteRacks()) {
                alert('Nemate opravneni mazat racky');
                return;
            }

            const client = clients.find(c => c.id === currentClientId);
            if (confirm(`Opravdu chcete smazat vsechna data klienta "${client.name}"? Tato akce je nevratna.`)) {
                racks = [];
                devices = [];
                connections = [];
                saveData();
                render();
            }
        }
        
        // Export data
        function exportData() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            
            const client = clients.find(c => c.id === currentClientId);
            const data = {
                client: client,
                racks,
                devices,
                connections,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rack-manager-${client.name.replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Import data
        function importData(event) {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta pro import dat');
                return;
            }
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.racks && data.devices) {
                        const client = clients.find(c => c.id === currentClientId);
                        if (confirm(`Import p콏ep칤코e v코echna st치vaj칤c칤 data klienta "${client.name}". Pokra캜ovat?`)) {
                            racks = data.racks || [];
                            devices = data.devices || [];
                            connections = data.connections || [];
                            saveData();
                            render();
                            alert('Data 칰sp캩코n캩 importov치na');
                        }
                    } else {
                        alert('Neplatn칳 form치t souboru');
                    }
                } catch (err) {
                    alert('Chyba p콏i importu: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // ==========================================
        // Firebase Realtime Database Functions
        // ==========================================
        
        // Save to Firebase Realtime Database
        function saveToFirebase() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            
            const client = clients.find(c => c.id === currentClientId);
            if (!client) return;
            
            // Prepare data for Firebase
            const dataToSave = {
                client: client,
                racks: racks,
                devices: devices,
                connections: connections,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                savedBy: auth.currentUser ? auth.currentUser.email : 'anonymous'
            };
            
            // Save to Firebase Realtime Database
            const clientRef = db.ref('clients/' + currentClientId);
            
            clientRef.set(dataToSave)
                .then(() => {
                    console.log('九 Data saved to Firebase');
                    alert('Data 칰sp캩코n캩 ulo쬰na do Firebase!');
                    
                    // Also save to localStorage as backup
                    saveData();
                })
                .catch((error) => {
                    console.error('仇 Firebase save error:', error);
                    alert('Chyba p콏i ukl치d치n칤 do Firebase: ' + error.message);
                });
        }
        
        // Load from Firebase Realtime Database
        function loadFromFirebase() {
            if (!currentClientId) {
                alert('Nejprve vyberte klienta');
                return;
            }
            
            const clientRef = db.ref('clients/' + currentClientId);
            
            clientRef.once('value')
                .then((snapshot) => {
                    const data = snapshot.val();
                    
                    if (data) {
                        // Load data from Firebase
                        if (data.racks) racks = data.racks;
                        if (data.devices) devices = data.devices;
                        if (data.connections) connections = data.connections;
                        
                        // Save to localStorage too
                        saveData();
                        
                        // Re-render
                        render();
                        
                        console.log('九 Data loaded from Firebase');
                        alert('Data na캜tena z Firebase!');
                    } else {
                        alert('Pro tohoto klienta nejsou v Firebase 쮂멳n치 data');
                    }
                })
                .catch((error) => {
                    console.error('仇 Firebase load error:', error);
                    alert('Chyba p콏i na캜칤t치n칤 z Firebase: ' + error.message);
                });
        }
        
        // Setup realtime sync for current client
        function setupRealtimeSync() {
            if (!currentClientId) return;
            
            // Remove previous listener if exists
            if (window.firebaseListener) {
                db.ref('clients/' + window.lastSyncedClient).off('value', window.firebaseListener);
            }
            
            // Setup new listener
            const clientRef = db.ref('clients/' + currentClientId);
            
            window.firebaseListener = clientRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data && data.timestamp) {
                    // Check if this is newer than our local data
                    const localTimestamp = localStorage.getItem('cxtech_lastUpdate_' + currentClientId);
                    
                    if (!localTimestamp || data.timestamp > parseInt(localTimestamp)) {
                        // Update from Firebase
                        if (data.racks) racks = data.racks;
                        if (data.devices) devices = data.devices;
                        if (data.connections) connections = data.connections;
                        
                        saveData();
                        render();
                        
                        console.log('游댃 Data synced from Firebase');
                    }
                }
            });
            
            window.lastSyncedClient = currentClientId;
        }
        
        // Add Firebase status indicator to UI
        function addFirebaseStatusIndicator() {
            const header = document.querySelector('.topbar');
            if (header && !document.getElementById('firebaseStatus')) {
                const statusDiv = document.createElement('div');
                statusDiv.id = 'firebaseStatus';
                statusDiv.style.cssText = 'font-size: 0.85rem; font-weight: 600; color: #b0b0b0;';
                statusDiv.innerHTML = 'Connecting...';
                header.appendChild(statusDiv);
            }
        }
        
        // Call on init
        addFirebaseStatusIndicator();
        window.addEventListener('load', init);
    </script>
   <!-- Firebase Auth + Realtime Database -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script>
  var auth;
  var db;

  // Load Firebase config from /api/config (Vercel env)
  async function loadFirebaseConfig() {
    var res = await fetch('/api/config');
    if (!res.ok) {
      throw new Error('Firebase config load failed');
    }
    return await res.json();
  }

  loadFirebaseConfig().then(function(firebaseConfig) {
    firebase.initializeApp(firebaseConfig);
    console.log('Firebase initialized for CX.TECH Rack Manager');

    auth = firebase.auth();
    db = firebase.database();
    window.auth = auth;
    window.db = db;

    function isLocalHost() {
      return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    }

    function updateLocalAdminUI(enabled) {
      var statusEl = document.getElementById('authStatus');
      var overlay = document.getElementById('authOverlay');
      if (enabled) {
        if (statusEl) statusEl.textContent = 'Local admin';
        if (overlay) overlay.classList.add('hidden');
        document.body.classList.remove('auth-locked');
        if (window.setCurrentRole) {
          window.setCurrentRole('admin');
        } else {
          setCurrentRole('admin');
        }
      }
    }

    function enableLocalAdmin() {
      if (!isLocalHost()) return;
      localStorage.setItem('localAdmin', 'true');
      updateLocalAdminUI(true);
    }

    function isLocalAdminActive() {
      return isLocalHost() && localStorage.getItem('localAdmin') === 'true';
    }

    var localAdminBtn = document.getElementById('localAdminBtn');
    if (localAdminBtn && isLocalHost()) {
      localAdminBtn.style.display = 'inline-block';
    }

    // Monitor Firebase connection status
    db.ref('.info/connected').on('value', function(snapshot) {
      var connected = snapshot.val();
      var statusElem = document.getElementById('firebaseStatus');
      if (statusElem) {
        if (connected) {
          statusElem.innerHTML = 'Online';
          statusElem.style.color = '#4ade80';
        } else {
          statusElem.innerHTML = 'Offline';
          statusElem.style.color = '#f87171';
        }
      }
      console.log('Firebase connection:', connected ? 'Online' : 'Offline');
    });

    // --- UI pro prihlaseni ---
    function updateAuthUI(user) {
      var statusEl = document.getElementById('authStatus');
      var loginBtn = document.getElementById('loginBtn');
      var logoutBtn = document.getElementById('logoutBtn');
      var overlay = document.getElementById('authOverlay');

      if (!statusEl || !loginBtn || !logoutBtn) return;

      if (!user && isLocalAdminActive()) {
        updateLocalAdminUI(true);
        loginBtn.style.display = 'none';
        logoutBtn.style.display = 'none';
        if (window.applyRolePermissions) {
          window.applyRolePermissions();
        }
        return;
      }

      if (user) {
        statusEl.textContent = 'Prihlasen: ' + (user.email || user.uid);
        loginBtn.style.display = 'none';
        logoutBtn.style.display = 'inline-block';
        if (overlay) overlay.classList.add('hidden');
        document.body.classList.remove('auth-locked');
      } else {
        statusEl.textContent = 'Neprihlasen';
        loginBtn.style.display = 'inline-block';
        logoutBtn.style.display = 'none';
        if (overlay) overlay.classList.remove('hidden');
        document.body.classList.add('auth-locked');
      }
      if (window.applyRolePermissions) {
        window.applyRolePermissions();
      }
    }

    function loginWithGoogle() {
      var provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).catch(function (error) {
        console.error('Auth error:', error);
        alert('Chyba pri prihlaseni: ' + error.message);
      });
    }

    function sendMagicLink() {
      var input = document.getElementById('emailLoginInput');
      var email = input ? input.value.trim() : '';
      if (!email || !email.includes('@')) {
        alert('Zadejte platny email');
        return;
      }
      var actionCodeSettings = {
        url: window.location.origin + window.location.pathname,
        handleCodeInApp: true
      };
      auth.sendSignInLinkToEmail(email, actionCodeSettings)
        .then(function() {
          window.localStorage.setItem('emailForSignIn', email);
          if (input) input.value = '';
          alert('Magic link byl odeslan na e-mail');
        })
        .catch(function(err) {
          console.error('Magic link error:', err);
          alert('Chyba pri odeslani magic linku: ' + err.message);
        });
    }

    if (auth.isSignInWithEmailLink(window.location.href)) {
      var email = window.localStorage.getItem('emailForSignIn');
      if (!email) {
        email = window.prompt('Zadejte email pro dokon?en? p?ihl??en?');
      }
      auth.signInWithEmailLink(email, window.location.href)
        .then(function() {
          window.localStorage.removeItem('emailForSignIn');
          window.history.replaceState({}, document.title, window.location.pathname);
        })
        .catch(function(err) {
          console.error('Email link sign-in error:', err);
          alert('Chyba pri prihlaseni: ' + err.message);
        });
    }

    function logout() {
      auth.signOut().catch(function (error) {
        console.error('Sign-out error:', error);
        alert('Chyba pri odhlaseni: ' + error.message);
      });
    }

    auth.onAuthStateChanged(function (user) {
      updateAuthUI(user);
      if (window.onAuthRoleChanged) {
        window.onAuthRoleChanged(user);
      }
    });

    function requireAuth() {
      var user = auth.currentUser;
      if (!user) {
        alert('Nejprve se prihlaste.');
        throw new Error('NOT_AUTHENTICATED');
      }
      return user;
    }

    window.loginWithGoogle = loginWithGoogle;
    window.sendMagicLink = sendMagicLink;
    window.logout = logout;
    window.requireAuth = requireAuth;
    window.enableLocalAdmin = enableLocalAdmin;
  }).catch(function(err) {
    console.error('Firebase config error:', err);
    alert('Firebase config error: ' + err.message);
  });

  // --- Cesta v Realtime DB, kde budeme drzet data ---
  var GLOBAL_PATH = "rackManager/global";

  // 驕 Ulo쬴t v코echna data z localStorage do Realtime DB
  async function saveToCloud() {
    try {
      var user = requireAuth();

      var clients = JSON.parse(localStorage.getItem('rackManagerClients') || '[]');
      var clientData = JSON.parse(localStorage.getItem('rackManagerClientData') || '{}');
      var lastClientId = localStorage.getItem('rackManagerLastClient') || null;

      var payload = {
        clients: clients,
        clientData: clientData,
        lastClientId: lastClientId,
        updatedAt: new Date().toISOString(),
        updatedBy: user.email || user.uid
      };

      await db.ref(GLOBAL_PATH).set(payload);
      alert("九 Data byla ulo쬰na do Realtime DB");
    } catch (err) {
      if (err.message === "NOT_AUTHENTICATED") return;
      console.error("Chyba p콏i ukl치d치n칤:", err);
      alert("仇 Chyba p콏i ukl치d치n칤 do cloudu: " + err.message);
    }
  }

  // 驕 Na캜칤st v코echna data z Realtime DB do localStorage
  async function loadFromCloud() {
    try {
      requireAuth();

      var snap = await db.ref(GLOBAL_PATH).once("value");
      if (!snap.exists()) {
        alert("丘 V cloudu zat칤m nejsou 쮂멳n치 data");
        return;
      }

      var data = snap.val() || {};
      var clients = data.clients || [];
      var clientData = data.clientData || {};
      var lastClientId = data.lastClientId || null;

      localStorage.setItem('rackManagerClients', JSON.stringify(clients));
      localStorage.setItem('rackManagerClientData', JSON.stringify(clientData));
      if (lastClientId) {
        localStorage.setItem('rackManagerLastClient', lastClientId);
      } else {
        localStorage.removeItem('rackManagerLastClient');
      }

      // p콏erenderovat UI podle nov칳ch dat
      if (typeof init === "function") {
        init();
      }

      alert("九 Data byla na캜tena z Realtime DB");
    } catch (err) {
      if (err.message === "NOT_AUTHENTICATED") return;
      console.error("Chyba p콏i na캜칤t치n칤:", err);
      alert("仇 Chyba p콏i na캜칤t치n칤 z cloudu: " + err.message);
    }
  }
</script>
</body>
</html>
